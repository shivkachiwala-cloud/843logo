<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dot Matrix Animation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Grid mode: No font required -->
    
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* NEW: Transparent BG logic */
            background-color: transparent;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="dotCanvas"></canvas>

    <script>
        // --- Embedded Settings ---
        const settings = {
  "inputMode": "grid",
  "gridCols": "30",
  "gridRows": "30",
  "gridData": "[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,\"#99bece\",0,0,\"#99bece\",0,0,0,0,\"#99bece\",0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,\"#99bece\",0,\"#99bece\",0,\"#99bece\",0,0,0,\"#99bece\",0,\"#99bece\",0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,\"#99bece\",0,\"#99bece\",0,\"#99bece\",0,0,0,0,0,\"#99bece\",0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,\"#6da0b2\",0,0,0,\"#6da0b2\",0,0,0,\"#6da0b2\",0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,\"#99bece\",0,\"#99bece\",0,0,0,\"#99bece\",0,0,0,\"#99bece\",0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,\"#99bece\",0,\"#99bece\",0,0,0,\"#99bece\",0,\"#99bece\",0,\"#99bece\",0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,\"#99bece\",0,0,0,0,\"#99bece\",0,0,\"#99bece\",0,0,\"#9faf6d\",0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]",
  "brushColor": "#9faf6d",
  "textInput": "DOTS",
  "fontFamily": "Inter",
  "fontWeight": "700",
  "textScale": "90",
  "dotSizeValue": "4",
  "hSpacing": "10",
  "vSpacing": "10",
  "staticRandomness": "0",
  "dotStyle": "fill",
  "dotColor": "#ffffff",
  "bgColor": "#111827",
  "transparentBg": true,
  "animationMode": "flickerLoop",
  "animationSpeed": "100",
  "transparency": "1",
  "jitterStrength": "10",
  "popStrength": "50",
  "mouseInteractionMode": "none",
  "mouseInteractionStrength": "50",
  "mouseInteractionRadius": "150"
};

        // --- DOM Elements ---
        const canvas = document.getElementById('dotCanvas');
        const ctx = canvas.getContext('2d');
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

        // --- State / Cache ---
        let cachedDotMatrix = [];
        let isAnimating = settings.animationMode !== 'none';
        let animationFrameId = null;
        let lastTimestamp = 0;
        let timeAccumulator = 0;

        // --- Mouse State ---
        let mouseX = -1;
        let mouseY = -1;

        
            // --- Init ---
            function init() {
                resizeCanvas();
                cachedDotMatrix = generateMatrixFromGrid();
                if (isAnimating) {
                    lastTimestamp = performance.now();
                    animationFrameId = requestAnimationFrame(animationLoop);
                } else {
                    drawDots(0, parseInt(settings.animationSpeed));
                }
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    if (!isAnimating) drawDots(0, parseInt(settings.animationSpeed));
                });
                if (settings.mouseInteractionMode !== 'none') {
                    canvas.addEventListener('mousemove', handleMouseMove);
                    canvas.addEventListener('mouseleave', handleMouseLeave);
                }
            }

            // --- Dot Matrix Generation (Grid Mode) ---
            function generateMatrixFromGrid() {
                const hSpacing = parseInt(settings.hSpacing);
                const vSpacing = parseInt(settings.vSpacing);
                const gridData = JSON.parse(settings.gridData);
                const gridRows = parseInt(settings.gridRows);
                const gridCols = parseInt(settings.gridCols);
                
                let matrix = [];
                for (let y = 0; y < gridRows; y++) {
                    for (let x = 0; x < gridCols; x++) {
                        // NEW: Check for color
                        if (gridData[y] && gridData[y][x] !== 0) {
                            matrix.push({ 
                                x: x * hSpacing, 
                                y: y * vSpacing,
                                staticRand: Math.random(),
                                color: gridData[y][x] // NEW
                            });
                        }
                    }
                }
                return matrix;
            }
            

        // --- Canvas Resizing ---
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            const newWidth = rect.width;
            const newHeight = rect.height;
            canvas.width = newWidth * dpr;
            canvas.height = newHeight * dpr;
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;
            ctx.scale(dpr, dpr);
        }

        // --- Mouse Interaction ---
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            mouseX = (event.clientX - rect.left);
            mouseY = (event.clientY - rect.top);
            if (isAnimating || settings.mouseInteractionMode !== 'none') {
                 if (!isAnimating) drawDots(0, parseInt(settings.animationSpeed));
            }
        }

        function handleMouseLeave() {
            mouseX = -1;
            mouseY = -1;
            if (settings.mouseInteractionMode !== 'none' && !isAnimating) {
                drawDots(0, parseInt(settings.animationSpeed));
            }
        }

        // --- Animation ---
        function animationLoop(currentTime) {
            if (!isAnimating) return;
            const deltaTime = currentTime - lastTimestamp;
            lastTimestamp = currentTime;
            timeAccumulator += deltaTime;
            drawDots(timeAccumulator, parseInt(settings.animationSpeed));
            animationFrameId = requestAnimationFrame(animationLoop);
        }

        // --- Draw Function ---
        function drawDots(elapsedTime, animationSpeed) {
            const dotSize = parseInt(settings.dotSizeValue);
            const dotStyle = settings.dotStyle;
            const dotColor = settings.dotColor; // Global color
            const bgColor = settings.bgColor;
            const isTransparent = settings.transparentBg; // NEW
            const transparencyFactor = parseFloat(settings.transparency);
            const staticRandomness = parseInt(settings.staticRandomness) / 100;
            const animationMode = settings.animationMode;
            const jitterStrength = parseInt(settings.jitterStrength);
            const popStrength = parseInt(settings.popStrength);
            const mouseMode = settings.mouseInteractionMode;
            const mouseStrength = parseInt(settings.mouseInteractionStrength);
            const mouseRadius = parseInt(settings.mouseInteractionRadius);
            
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            const canvasHeight = canvas.height / dpr;

            // NEW: Handle transparency
            if (isTransparent) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            } else {
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
            
            if (cachedDotMatrix.length === 0) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const dot of cachedDotMatrix) {
                if (dot.x < minX) minX = dot.x;
                if (dot.x > maxX) maxX = dot.x;
                if (dot.y < minY) minY = dot.y;
                if (dot.y > maxY) maxY = dot.y;
            }
            const matrixWidth = (maxX - minX) || 1;
            const matrixHeight = (maxY - minY) || 1;
            const scaleX = canvasWidth / matrixWidth;
            const scaleY = canvasHeight / matrixHeight;
            
            
            const scale = Math.min(scaleX, scaleY) * 0.9;
            
            
            const drawOffsetX = (canvasWidth - (matrixWidth * scale)) / 2 - (minX * scale);
            const drawOffsetY = (canvasHeight - (matrixHeight * scale)) / 2 - (minY * scale);

            // ctx.lineWidth = Math.max(1, dotSize / 4); // OLD

            // NEW: Calculate scaled dot size for proportional scaling
            const scaledDotSize = dotSize * scale;
            ctx.lineWidth = Math.max(1, scaledDotSize / 4); // NEW

            for (const dot of cachedDotMatrix) {
                // NEW: Get dot-specific or global color
                const currentDotColor = (dot.color) ? dot.color : dotColor;
                
                let currentAlpha = 1;
                // let currentDotSize = dotSize; // OLD
                let currentDotSize = scaledDotSize; // NEW
                let drawX = dot.x * scale + drawOffsetX;
                let drawY = dot.y * scale + drawOffsetY;

                if (isAnimating) {
                    const time = elapsedTime / 1000.0;
                    switch (animationMode) {
                        case 'wave':
                            const waveSpeed = 0.1 + (animationSpeed / 100) * 1.9;
                            const wave = Math.sin(drawX * 0.02 + time * waveSpeed);
                            currentAlpha = (wave + 1) / 2;
                            currentAlpha = 1 - transparencyFactor + (currentAlpha * transparencyFactor);
                            break;
                        case 'fade':
                            const fadeSpeed = 0.1 + (animationSpeed / 100) * 1.9;
                            const fade = (Math.sin(time * fadeSpeed) + 1) / 2;
                            currentAlpha = 1 - (fade * transparencyFactor);
                            break;
                        case 'flicker':
                            const baseFreq = 0.05 + ((animationSpeed - 1) / 99) * 4.95;
                            const dotFreq = 0.5 + dot.staticRand;
                            const dotOffset = dot.staticRand * 100;
                            const flickerValue = (Math.sin(time * baseFreq * dotFreq + dotOffset) + 1) / 2;
                            currentAlpha = (1 - transparencyFactor) + (flickerValue * transparencyFactor);
                            break;
                        case 'flickerLoop':
                            const loopDuration = 7.0; 
                            const stillEndTime = 2.0;
                            const flickerStartTime = 3.0;
                            const flickerEndTime = 6.0;
                            const loopEndTime = 7.0;
                            const timeInLoop = time % loopDuration;
                            const stillAlpha = 1.0; // Full visibility
                            
                            const baseFreq_loop = 0.05 + ((animationSpeed - 1) / 99) * 4.95;
                            const dotFreq_loop = 0.5 + dot.staticRand;
                            const dotOffset_loop = dot.staticRand * 100;
                            const flickerValue_loop = (Math.sin(time * baseFreq_loop * dotFreq_loop + dotOffset_loop) + 1) / 2;
                            const flickerAlpha = (1 - transparencyFactor) + (flickerValue_loop * transparencyFactor);

                            let transitionAmount = 0.0;
                            if (timeInLoop < stillEndTime) {
                                transitionAmount = 0.0;
                            } else if (timeInLoop < flickerStartTime) {
                                transitionAmount = (timeInLoop - stillEndTime) / (flickerStartTime - stillEndTime);
                            } else if (timeInLoop < flickerEndTime) {
                                transitionAmount = 1.0;
                            } else {
                                transitionAmount = 1.0 - ((timeInLoop - flickerEndTime) / (loopEndTime - flickerEndTime));
                            }
                            currentAlpha = (1 - transitionAmount) * stillAlpha + transitionAmount * flickerAlpha;
                            break;
                        case 'jitter':
                            const jitterX = (Math.random() - 0.5) * (jitterStrength / 10);
                            const jitterY = (Math.random() - 0.5) * (jitterStrength / 10);
                            drawX += jitterX;
                            drawY += jitterY;
                            break;
                        case 'pop':
                            const popSpeed = 0.5 + (animationSpeed / 100) * 2.5;
                            const popTime = time * popSpeed + (dot.x + dot.y) * 0.01;
                            const popScale = (Math.sin(popTime * 2) + 1) / 2;
                            const popAmount = 1 + (popScale * (popStrength / 100));
                            currentDotSize *= popAmount;
                            break;
                    }
                } else {
                    const baseAlpha = 1 - transparencyFactor;
                    const randomAlpha = 1 - (dot.staticRand * staticRandomness);
                    currentAlpha = Math.min(baseAlpha, randomAlpha);
                }
                
                currentAlpha = Math.max(0, Math.min(1, currentAlpha));

                // Mouse Interaction
                if (mouseX !== -1 && mouseY !== -1 && mouseMode !== 'none' && mouseStrength > 0) {
                    const dx = drawX - mouseX;
                    const dy = drawY - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < mouseRadius && distance > 0.1) {
                        const force = (mouseRadius - distance) / mouseRadius;
                        const strength = (mouseStrength / 100);
                        switch (mouseMode) {
                            case 'repel':
                                const repelForce = force * strength * (mouseRadius / 5);
                                drawX += (dx / distance) * repelForce;
                                drawY += (dy / distance) * repelForce;
                                break;
                            case 'attract':
                                const attractForce = force * strength * (mouseRadius / 5);
                                drawX -= (dx / distance) * attractForce;
                                drawY -= (dy / distance) * attractForce;
                                break;
                            case 'highlight':
                                const highlightMultiplier = 1 + (force * strength);
                                currentDotSize *= highlightMultiplier;
                                break;
                        }
                    }
                }
                
                // NEW: Use determined color
                ctx.fillStyle = hexToRgba(currentDotColor, currentAlpha);
                ctx.strokeStyle = hexToRgba(currentDotColor, currentAlpha);
                ctx.beginPath();
                
                if (dotStyle === 'square') {
                    ctx.fillRect(drawX - currentDotSize / 2, drawY - currentDotSize / 2, currentDotSize, currentDotSize);
                } else {
                    ctx.arc(drawX, drawY, currentDotSize / 2, 0, Math.PI * 2);
                    if (dotStyle === 'fill') {
                        ctx.fill();
                    } else {
                        ctx.stroke();
                    }
                }
            }
        }

        // --- Helper: Convert Hex to RGBA ---
        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length == 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // --- Start ---
        init();
    </script>
</body>
</html>